<!DOCTYPE html>
<html lang="en">
  <head>
    <title>GettingStarted  Reference</title>
    <link rel="stylesheet" type="text/css" href="css/jazzy.css" />
    <link rel="stylesheet" type="text/css" href="css/highlight.css" />
    <meta charset="utf-8">
    <script src="js/jquery.min.js" defer></script>
    <script src="js/jazzy.js" defer></script>
    
    <script src="js/lunr.min.js" defer></script>
    <script src="js/typeahead.jquery.js" defer></script>
    <script src="js/jazzy.search.js" defer></script>
  </head>
  <body>


    <a title="GettingStarted  Reference"></a>

    <header class="header">
      <p class="header-col header-col--primary">
        <a class="header-link" href="index.html">
           Docs
        </a>
         (68% documented)
      </p>
    
      <p class="header-col--secondary">
        <form role="search" action="search.json">
          <input type="text" placeholder="Search documentation" data-typeahead>
        </form>
      </p>
    
        <p class="header-col header-col--secondary">
          <a class="header-link" href="https://github.com/mxcl/PromiseKit">
            <img class="header-icon" src="img/gh.png"/>
            View on GitHub
          </a>
        </p>
    
        <p class="header-col header-col--secondary">
          <a class="header-link" href="dash-feed://https%3A%2F%2Fpromisekit%2Eorg%2Freference%2Fdocsets%2F%2Exml">
            <img class="header-icon" src="img/dash.png"/>
            Install in Dash
          </a>
        </p>
    </header>

    <p class="breadcrumbs">
      <a class="breadcrumb" href="index.html"> Reference</a>
      <img class="carat" src="img/carat.png" />
      GettingStarted  Reference
    </p>

    <div class="content-wrapper">
      <nav class="navigation">
        <ul class="nav-groups">
          <li class="nav-group-name">
            <a class="nav-group-name-link" href="Guides.html">Guides</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="appendix.html">Appendix</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="commonpatterns.html">CommonPatterns</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="faq.html">FAQ</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="gettingstarted.html">GettingStarted</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="installation.html">Installation</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="objectivec.html">ObjectiveC</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="readme.html">README</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="troubleshooting.html">Troubleshooting</a>
              </li>
            </ul>
          </li>
          <li class="nav-group-name">
            <a class="nav-group-name-link" href="Classes.html">Classes</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Classes/Box.html">Box</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Classes/EmptyBox.html">EmptyBox</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Classes/Guarantee.html">Guarantee</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Classes/Handlers.html">Handlers</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Classes/PMKFinalizer.html">PMKFinalizer</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Classes/Promise.html">Promise</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Classes/Resolver.html">Resolver</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Classes/SealedBox.html">SealedBox</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Classes/__AnyPromise.html">__AnyPromise</a>
              </li>
            </ul>
          </li>
          <li class="nav-group-name">
            <a class="nav-group-name-link" href="Global Variables.html">Global Variables</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Global Variables.html#/s:10PromiseKit4confAA16PMKConfigurationVvp">conf</a>
              </li>
            </ul>
          </li>
          <li class="nav-group-name">
            <a class="nav-group-name-link" href="Enums.html">Enumerations</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Enums/CatchPolicy.html">CatchPolicy</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Enums/LogEvent.html">LogEvent</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Enums/PMKError.html">PMKError</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Enums/PMKNamespacer.html">PMKNamespacer</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Enums/PMKUnambiguousInitializer.html">PMKUnambiguousInitializer</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Enums/Result.html">Result</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Enums/Sealant.html">Sealant</a>
              </li>
            </ul>
          </li>
          <li class="nav-group-name">
            <a class="nav-group-name-link" href="Extensions.html">Extensions</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Extensions/AnyPromise.html">AnyPromise</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Extensions/DispatchQueue.html">DispatchQueue</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Extensions/Error.html">Error</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Extensions/Optional.html">Optional</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Extensions/PromiseKit.html">PromiseKit</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Extensions/PromiseKit/Result.html">– Result</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Extensions/Thread.html">Thread</a>
              </li>
            </ul>
          </li>
          <li class="nav-group-name">
            <a class="nav-group-name-link" href="Functions.html">Functions</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Functions.html#/s:10PromiseKit5afteryAA9GuaranteeCyytG8Dispatch0E12TimeIntervalOF">after(_:)</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Functions.html#/s:10PromiseKit5after7secondsAA9GuaranteeCyytGSd_tF">after(seconds:)</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Functions.html#/s:10PromiseKit7firstly7executeAA0A0Cy1TQzGxyKXE_tAA8ThenableRzlF">firstly(execute:)</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Functions.html#/s:10PromiseKit7firstly7executeAA9GuaranteeCyxGAFyXE_tlF">firstly(execute:)</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Functions.html#/s:10PromiseKit4hangyxAA0A0CyxGKlF">hang(_:)</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Functions.html#/s:10PromiseKit4raceyAA0A0Cy1TQzGSayxGAA8ThenableRzlF">race(_:)</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Functions.html#/s:10PromiseKit4raceyAA0A0Cy1TQzGxd_tAA8ThenableRzlF">race(_:)</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Functions.html#/s:10PromiseKit4raceyAA9GuaranteeCyxGAEd_tlF">race(_:)</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Functions.html#/s:10PromiseKit4whenyAA9GuaranteeCyytGAEd_tF">when(_:)</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Functions.html#/s:10PromiseKit4when9fulfilledAA0A0CySay1TQzGGSayxG_tAA8ThenableRzlF">when(fulfilled:)</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Functions.html#/s:10PromiseKit4when9fulfilledAA0A0CyytGSayxG_tAA8ThenableRzyt1TRtzlF">when(fulfilled:)</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Functions.html#/s:10PromiseKit4when9fulfilledAA0A0CyytGxd_tAA8ThenableRzyt1TRtzlF">when(fulfilled:)</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Functions.html#/s:10PromiseKit4when9fulfilled_AA0A0Cy1TQz_AFQy_tGx_q_tAA8ThenableRzAaJR_r0_lF">when(fulfilled:_:)</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Functions.html#/s:10PromiseKit4when9fulfilled__AA0A0Cy1TQz_AFQy_AFQy0_tGx_q_q0_tAA8ThenableRzAaKR_AaKR0_r1_lF">when(fulfilled:_:_:)</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Functions.html#/s:10PromiseKit4when9fulfilled___AA0A0Cy1TQz_AFQy_AFQy0_AFQy1_tGx_q_q0_q1_tAA8ThenableRzAaLR_AaLR0_AaLR1_r2_lF">when(fulfilled:_:_:_:)</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Functions.html#/s:10PromiseKit4when9fulfilled____AA0A0Cy1TQz_AFQy_AFQy0_AFQy1_AFQy2_tGx_q_q0_q1_q2_tAA8ThenableRzAaMR_AaMR0_AaMR1_AaMR2_r3_lF">when(fulfilled:_:_:_:_:)</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Functions.html#/s:10PromiseKit4when9fulfilled12concurrentlyAA0A0CySay7Element_1TQZGGx_SitStRzAA8ThenableAGRpzlF">when(fulfilled:concurrently:)</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Functions.html#/s:10PromiseKit4when10guaranteesAA9GuaranteeCyytGSayAFG_tF">when(guarantees:)</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Functions.html#/s:10PromiseKit4when8resolvedAA9GuaranteeCySayAA6ResultOyxGGGAA0A0CyxGd_tlF">when(resolved:)</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Functions.html#/s:10PromiseKit4when8resolvedAA9GuaranteeCySayAA6ResultOyxGGGSayAA0A0CyxGG_tlF">when(resolved:)</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Functions.html#/s:10PromiseKit4wrapyAA0A0CyxGyys5Error_pSg_xSgtcKXElF">wrap(_:)</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Functions.html#/s:10PromiseKit4wrapyAA0A0CyxGyyxSg_s5Error_pSgtcKXElF">wrap(_:)</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Functions.html#/s:10PromiseKit4wrapyAA0A0CyxGyyx_s5Error_pSgtcKXElF">wrap(_:)</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Functions.html#/s:10PromiseKit4wrapyAA0A0CyxGyyxcKXElF">wrap(_:)</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Functions.html#/s:10PromiseKit4wrapyAA0A0CyytGyys5Error_pSgcKXEF">wrap(_:)</a>
              </li>
            </ul>
          </li>
          <li class="nav-group-name">
            <a class="nav-group-name-link" href="Protocols.html">Protocols</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Protocols/CancellableError.html">CancellableError</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Protocols/CatchMixin.html">CatchMixin</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Protocols/Thenable.html">Thenable</a>
              </li>
            </ul>
          </li>
          <li class="nav-group-name">
            <a class="nav-group-name-link" href="Structs.html">Structures</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Structs/PMKConfiguration.html">PMKConfiguration</a>
              </li>
            </ul>
          </li>
        </ul>
      </nav>
      <article class="main-content">

        <section class="section">
          <div class="section-content">
            
            <h1 id='code-then-code-and-code-done-code' class='heading'><code>then</code> and <code>done</code></h1>

<p>Here is a typical promise chain:</p>
<pre class="highlight swift"><code><span class="n">firstly</span> <span class="p">{</span>
    <span class="nf">login</span><span class="p">()</span>
<span class="p">}</span><span class="o">.</span><span class="n">then</span> <span class="p">{</span> <span class="n">creds</span> <span class="k">in</span>
    <span class="nf">fetch</span><span class="p">(</span><span class="nv">avatar</span><span class="p">:</span> <span class="n">creds</span><span class="o">.</span><span class="n">user</span><span class="p">)</span>
<span class="p">}</span><span class="o">.</span><span class="n">done</span> <span class="p">{</span> <span class="n">image</span> <span class="k">in</span>
    <span class="k">self</span><span class="o">.</span><span class="n">imageView</span> <span class="o">=</span> <span class="n">image</span>
<span class="p">}</span>
</code></pre>

<p>If this code used completion handlers, it would look like this:</p>
<pre class="highlight swift"><code><span class="n">login</span> <span class="p">{</span> <span class="n">creds</span><span class="p">,</span> <span class="n">error</span> <span class="k">in</span>
    <span class="k">if</span> <span class="k">let</span> <span class="nv">creds</span> <span class="o">=</span> <span class="n">creds</span> <span class="p">{</span>
        <span class="nf">fetch</span><span class="p">(</span><span class="nv">avatar</span><span class="p">:</span> <span class="n">creds</span><span class="o">.</span><span class="n">user</span><span class="p">)</span> <span class="p">{</span> <span class="n">image</span><span class="p">,</span> <span class="n">error</span> <span class="k">in</span>
            <span class="k">if</span> <span class="k">let</span> <span class="nv">image</span> <span class="o">=</span> <span class="n">image</span> <span class="p">{</span>
                <span class="k">self</span><span class="o">.</span><span class="n">imageView</span> <span class="o">=</span> <span class="n">image</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>

<p><code>then</code> <em>is</em> just another way to structure completion handlers, but it is also quite a
bit more. At this initial stage of our understanding, it mostly helps
readability. The promise chain above is easy to scan and understand: one asynchronous
operation leads into the other, line by line. It&rsquo;s as close to
procedural code as we can easily come given the current state of Swift.</p>

<p><code>done</code> is the same as <code>then</code> but you cannot return a promise. It is 
typically the end of the “success” part of the chain. Above, you can see that we
receive the final image in our <code>done</code> and use it to set up the UI.</p>

<p>Let’s compare the signatures of the two login methods:</p>
<pre class="highlight swift"><code><span class="kd">func</span> <span class="nf">login</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">Promise</span><span class="o">&lt;</span><span class="kt">Creds</span><span class="o">&gt;</span>

<span class="c1">// Compared with:</span>

<span class="kd">func</span> <span class="nf">login</span><span class="p">(</span><span class="nv">completion</span><span class="p">:</span> <span class="p">(</span><span class="kt">Creds</span><span class="p">?,</span> <span class="kt">Error</span><span class="p">?)</span> <span class="o">-&gt;</span> <span class="kt">Void</span><span class="p">)</span>
                        <span class="c1">// ^^ ugh. Optionals. Double optionals.</span>
</code></pre>

<p>The distinction is that with promises, your functions return <em>promises</em> instead 
of accepting and running callbacks. Each handler in a chain returns a promise. 
<code><a href="Classes/Promise.html">Promise</a></code> objects define the <code>then</code> method, which waits for the completion of the
promise before continuing the chain. Chains resolve procedurally, one promise
at a time.</p>

<p>A <code><a href="Classes/Promise.html">Promise</a></code> represents the future value of an asynchronous task. It has a type
that represents the type of object it wraps. For example, in the example above,
<code>login</code> is a function that returns a <code><a href="Classes/Promise.html">Promise</a></code> that <em>will</em> represent an instance
of <code>Creds</code>.</p>

<blockquote>
<p><em>Note</em>: <code>done</code> is new to PromiseKit 5. We previously defined a variant of <code>then</code> that
did not require you to return a promise. Unfortunately, this convention often confused
Swift and led to odd and hard-to-debug error messages. It also made using PromiseKit 
more painful. The introduction of <code>done</code> lets you type out promise chains that
compile without additional qualification to help the compiler figure out type information.</p>
</blockquote>

<hr>

<p>You may notice that unlike the completion pattern, the promise chain appears to
ignore errors. This is not the case! In fact, it has the opposite effect: the promise
chain makes error handling more accessible and makes errors harder to ignore.</p>
<h1 id='code-catch-code' class='heading'><code>catch</code></h1>

<p>With promises, errors cascade along the promise chain, ensuring that your apps are
robust and your code is clear:</p>
<pre class="highlight swift"><code><span class="n">firstly</span> <span class="p">{</span>
    <span class="nf">login</span><span class="p">()</span>
<span class="p">}</span><span class="o">.</span><span class="n">then</span> <span class="p">{</span> <span class="n">creds</span> <span class="k">in</span>
    <span class="nf">fetch</span><span class="p">(</span><span class="nv">avatar</span><span class="p">:</span> <span class="n">creds</span><span class="o">.</span><span class="n">user</span><span class="p">)</span>
<span class="p">}</span><span class="o">.</span><span class="n">done</span> <span class="p">{</span> <span class="n">image</span> <span class="k">in</span>
    <span class="k">self</span><span class="o">.</span><span class="n">imageView</span> <span class="o">=</span> <span class="n">image</span>
<span class="p">}</span><span class="o">.</span><span class="k">catch</span> <span class="p">{</span>
    <span class="c1">// any errors in the whole chain land here</span>
<span class="p">}</span>
</code></pre>

<blockquote>
<p>Swift emits a warning if you forget to <code>catch</code> a chain. But we&rsquo;ll
talk about that in more detail later.</p>
</blockquote>

<p>Each promise is an object that represents an individual, asynchronous task.
If a task fails, its promise becomes <em>rejected</em>. Chains that contain rejected
promises skip all subsequent <code>then</code>s. Instead, the next <code>catch</code> is executed.
(Strictly speaking, <em>all</em> subsequent <code>catch</code> handlers are executed.)</p>

<p>For fun, let’s compare this pattern with its completion handler equivalent:</p>
<pre class="highlight swift"><code><span class="kd">func</span> <span class="nf">handle</span><span class="p">(</span><span class="nv">error</span><span class="p">:</span> <span class="kt">Error</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">//…</span>
<span class="p">}</span>

<span class="n">login</span> <span class="p">{</span> <span class="n">creds</span><span class="p">,</span> <span class="n">error</span> <span class="k">in</span>
    <span class="k">guard</span> <span class="k">let</span> <span class="nv">creds</span> <span class="o">=</span> <span class="n">creds</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="nf">handle</span><span class="p">(</span><span class="nv">error</span><span class="p">:</span> <span class="n">error</span><span class="o">!</span><span class="p">)</span> <span class="p">}</span>
    <span class="nf">fetch</span><span class="p">(</span><span class="nv">avatar</span><span class="p">:</span> <span class="n">creds</span><span class="o">.</span><span class="n">user</span><span class="p">)</span> <span class="p">{</span> <span class="n">image</span><span class="p">,</span> <span class="n">error</span> <span class="k">in</span>
        <span class="k">guard</span> <span class="k">let</span> <span class="nv">image</span> <span class="o">=</span> <span class="n">image</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="nf">handle</span><span class="p">(</span><span class="nv">error</span><span class="p">:</span> <span class="n">error</span><span class="o">!</span><span class="p">)</span> <span class="p">}</span>
        <span class="k">self</span><span class="o">.</span><span class="n">imageView</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">image</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>

<p>The use of <code>guard</code> and a consolidated error handler help, but the promise chain’s
readability speaks for itself.</p>
<h1 id='code-ensure-code' class='heading'><code>ensure</code></h1>

<p>We have learned to compose asynchronicity. Next let’s extend our primitives:</p>
<pre class="highlight swift"><code><span class="n">firstly</span> <span class="p">{</span>
    <span class="kt">UIApplication</span><span class="o">.</span><span class="n">shared</span><span class="o">.</span><span class="n">isNetworkActivityIndicatorVisible</span> <span class="o">=</span> <span class="kc">true</span>
    <span class="k">return</span> <span class="nf">login</span><span class="p">()</span>
<span class="p">}</span><span class="o">.</span><span class="n">then</span> <span class="p">{</span>
    <span class="nf">fetch</span><span class="p">(</span><span class="nv">avatar</span><span class="p">:</span> <span class="nv">$0</span><span class="o">.</span><span class="n">user</span><span class="p">)</span>
<span class="p">}</span><span class="o">.</span><span class="n">done</span> <span class="p">{</span>
    <span class="k">self</span><span class="o">.</span><span class="n">imageView</span> <span class="o">=</span> <span class="nv">$0</span>
<span class="p">}</span><span class="o">.</span><span class="n">ensure</span> <span class="p">{</span>
    <span class="kt">UIApplication</span><span class="o">.</span><span class="n">shared</span><span class="o">.</span><span class="n">isNetworkActivityIndicatorVisible</span> <span class="o">=</span> <span class="kc">false</span>
<span class="p">}</span><span class="o">.</span><span class="k">catch</span> <span class="p">{</span>
    <span class="c1">//…</span>
<span class="p">}</span>
</code></pre>

<p>No matter the outcome of your chain—-failure or success—-your <code>ensure</code>
handler is always called.</p>

<p>Let’s compare this pattern with its completion handler equivalent:</p>
<pre class="highlight swift"><code><span class="kt">UIApplication</span><span class="o">.</span><span class="n">shared</span><span class="o">.</span><span class="n">isNetworkActivityIndicatorVisible</span> <span class="o">=</span> <span class="kc">true</span>

<span class="kd">func</span> <span class="nf">handle</span><span class="p">(</span><span class="nv">error</span><span class="p">:</span> <span class="kt">Error</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">UIApplication</span><span class="o">.</span><span class="n">shared</span><span class="o">.</span><span class="n">isNetworkActivityIndicatorVisible</span> <span class="o">=</span> <span class="kc">false</span>
    <span class="c1">//…</span>
<span class="p">}</span>

<span class="n">login</span> <span class="p">{</span> <span class="n">creds</span><span class="p">,</span> <span class="n">error</span> <span class="k">in</span>
    <span class="k">guard</span> <span class="k">let</span> <span class="nv">creds</span> <span class="o">=</span> <span class="n">creds</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="nf">handle</span><span class="p">(</span><span class="nv">error</span><span class="p">:</span> <span class="n">error</span><span class="o">!</span><span class="p">)</span> <span class="p">}</span>
    <span class="nf">fetch</span><span class="p">(</span><span class="nv">avatar</span><span class="p">:</span> <span class="n">creds</span><span class="o">.</span><span class="n">user</span><span class="p">)</span> <span class="p">{</span> <span class="n">image</span><span class="p">,</span> <span class="n">error</span> <span class="k">in</span>
        <span class="k">guard</span> <span class="k">let</span> <span class="nv">image</span> <span class="o">=</span> <span class="n">image</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="nf">handle</span><span class="p">(</span><span class="nv">error</span><span class="p">:</span> <span class="n">error</span><span class="o">!</span><span class="p">)</span> <span class="p">}</span>
        <span class="k">self</span><span class="o">.</span><span class="n">imageView</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">image</span>
        <span class="kt">UIApplication</span><span class="o">.</span><span class="n">shared</span><span class="o">.</span><span class="n">isNetworkActivityIndicatorVisible</span> <span class="o">=</span> <span class="kc">false</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>

<p>It would be very easy for someone to amend this code and forget to unset 
the activity indicator, leading to a bug. With promises, this type of error is
almost impossible: the Swift compiler resists your supplementing the chain without 
using promises. You almost won’t need to review the pull requests.</p>

<blockquote>
<p><em>Note</em>: PromiseKit has perhaps capriciously switched between the names <code>always</code>
and <code>ensure</code> for this function several times in the past. Sorry about this. We suck.</p>
</blockquote>

<p>You can also use <code>finally</code> as an <code>ensure</code> that terminates the promise chain and does not return a value:</p>
<pre class="highlight plaintext"><code>spinner(visible: true)

firstly {
    foo()
}.done {
    //…
}.catch {
    //…
}.finally {
    self.spinner(visible: false)
}
</code></pre>
<h1 id='code-when-code' class='heading'><code>when</code></h1>

<p>With completion handlers, reacting to multiple asynchronous operations is either
slow or hard. Slow means doing it serially:</p>
<pre class="highlight swift"><code><span class="n">operation1</span> <span class="p">{</span> <span class="n">result1</span> <span class="k">in</span>
    <span class="n">operation2</span> <span class="p">{</span> <span class="n">result2</span> <span class="k">in</span>
        <span class="nf">finish</span><span class="p">(</span><span class="n">result1</span><span class="p">,</span> <span class="n">result2</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>

<p>The fast (<em>parallel</em>) path code makes the code less clear:</p>
<pre class="highlight swift"><code><span class="k">var</span> <span class="nv">result1</span><span class="p">:</span> <span class="err">…</span><span class="o">!</span>
<span class="k">var</span> <span class="nv">result2</span><span class="p">:</span> <span class="err">…</span><span class="o">!</span>
<span class="k">let</span> <span class="nv">group</span> <span class="o">=</span> <span class="kt">DispatchGroup</span><span class="p">()</span>
<span class="n">group</span><span class="o">.</span><span class="nf">enter</span><span class="p">()</span>
<span class="n">group</span><span class="o">.</span><span class="nf">enter</span><span class="p">()</span>
<span class="n">operation1</span> <span class="p">{</span>
    <span class="n">result1</span> <span class="o">=</span> <span class="nv">$0</span>
    <span class="n">group</span><span class="o">.</span><span class="nf">leave</span><span class="p">()</span>
<span class="p">}</span>
<span class="n">operation2</span> <span class="p">{</span>
    <span class="n">result2</span> <span class="o">=</span> <span class="nv">$0</span>
    <span class="n">group</span><span class="o">.</span><span class="nf">leave</span><span class="p">()</span>
<span class="p">}</span>
<span class="n">group</span><span class="o">.</span><span class="nf">notify</span><span class="p">(</span><span class="nv">queue</span><span class="p">:</span> <span class="o">.</span><span class="n">main</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">finish</span><span class="p">(</span><span class="n">result1</span><span class="p">,</span> <span class="n">result2</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>

<p>Promises are easier:</p>
<pre class="highlight swift"><code><span class="n">firstly</span> <span class="p">{</span>
    <span class="nf">when</span><span class="p">(</span><span class="nv">fulfilled</span><span class="p">:</span> <span class="nf">operation1</span><span class="p">(),</span> <span class="nf">operation2</span><span class="p">())</span>
<span class="p">}</span><span class="o">.</span><span class="n">done</span> <span class="p">{</span> <span class="n">result1</span><span class="p">,</span> <span class="n">result2</span> <span class="k">in</span>
    <span class="c1">//…</span>
<span class="p">}</span>
</code></pre>

<p><code>when</code> takes promises, waits for them to resolve and returns a promise containing the results.</p>

<p>As with any promise chain, if any of the component promises fail, the chain calls the next <code>catch</code>.</p>
<h1 id='promisekit-extensions' class='heading'>PromiseKit Extensions</h1>

<p>When we made PromiseKit, we understood that we wanted to use <em>only</em> promises to implement 
asynchronous behavior. So wherever possible, we offer extensions to Apple’s APIs that reframe
the API in terms of promises. For example:</p>
<pre class="highlight swift"><code><span class="n">firstly</span> <span class="p">{</span>
    <span class="kt">CLLocationManager</span><span class="o">.</span><span class="nf">promise</span><span class="p">()</span>
<span class="p">}</span><span class="o">.</span><span class="n">then</span> <span class="p">{</span> <span class="n">location</span> <span class="k">in</span>
    <span class="kt">CLGeocoder</span><span class="o">.</span><span class="nf">reverseGeocode</span><span class="p">(</span><span class="n">location</span><span class="p">)</span>
<span class="p">}</span><span class="o">.</span><span class="n">done</span> <span class="p">{</span> <span class="n">placemarks</span> <span class="k">in</span>
    <span class="k">self</span><span class="o">.</span><span class="n">placemark</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="s">"</span><span class="se">\(</span><span class="n">placemarks</span><span class="o">.</span><span class="n">first</span><span class="se">)</span><span class="s">"</span>
<span class="p">}</span>
</code></pre>

<p>To use these extensions, you need to specify subspecs:</p>
<pre class="highlight ruby"><code><span class="n">pod</span> <span class="s2">"PromiseKit"</span>
<span class="n">pod</span> <span class="s2">"PromiseKit/CoreLocation"</span>
<span class="n">pod</span> <span class="s2">"PromiseKit/MapKit"</span>
</code></pre>

<p>All of these extensions are available at the <a href="https://github.com/PromiseKit">PromiseKit organization</a>.
Go there to see what&rsquo;s available and to read the source code and documentation. Every file and function
has been copiously documented.</p>

<blockquote>
<p>We also provide extensions for common libraries such as <a href="https://github.com/PromiseKit/Alamofire-">Alamofire</a>.</p>
</blockquote>
<h1 id='making-promises' class='heading'>Making Promises</h1>

<p>The standard extensions will take you a long way, but sometimes you&rsquo;ll still need to start chains
of your own. Maybe you&rsquo;re using a third party API that doesn’t provide promises, or perhaps you wrote
your own asynchronous system. Either way, it&rsquo;s easy to add promises. If you look at the code of the
standard extensions, you&rsquo;ll see that it uses the same approach  described below.</p>

<p>Let’s say we have the following method:</p>
<pre class="highlight swift"><code><span class="kd">func</span> <span class="nf">fetch</span><span class="p">(</span><span class="nv">completion</span><span class="p">:</span> <span class="p">(</span><span class="kt">String</span><span class="p">?,</span> <span class="kt">Error</span><span class="p">?)</span> <span class="o">-&gt;</span> <span class="kt">Void</span><span class="p">)</span>
</code></pre>

<p>How do we convert this to a promise? Well, it&rsquo;s easy:</p>
<pre class="highlight swift"><code><span class="kd">func</span> <span class="nf">fetch</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">Promise</span><span class="o">&lt;</span><span class="kt">String</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kt">Promise</span> <span class="p">{</span> <span class="nf">fetch</span><span class="p">(</span><span class="nv">completion</span><span class="p">:</span> <span class="nv">$0</span><span class="o">.</span><span class="n">resolve</span><span class="p">)</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre>

<p>You may find the expanded version more readable:</p>
<pre class="highlight swift"><code><span class="kd">func</span> <span class="nf">fetch</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">Promise</span><span class="o">&lt;</span><span class="kt">String</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kt">Promise</span> <span class="p">{</span> <span class="n">seal</span> <span class="k">in</span>
        <span class="n">fetch</span> <span class="p">{</span> <span class="n">result</span><span class="p">,</span> <span class="n">error</span> <span class="k">in</span>
            <span class="n">seal</span><span class="o">.</span><span class="nf">resolve</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">error</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>

<p>The <code>seal</code> object that the <code><a href="Classes/Promise.html">Promise</a></code> initializer provides to you defines 
many methods for handling garden-variety completion handlers. It even 
covers a variety of rarer situations, thus making it easy for you to add 
promises to an existing codebase.</p>

<blockquote>
<p><em>Note</em>: We tried to make it so that you could just do <code>Promise(fetch)</code>, but we
were not able to make this simpler pattern work universally without requiring
extra disambiguation for the Swift compiler. Sorry; we tried.</p>

<p><em>Note</em>: In PMK 4, this initializer provided two parameters to your closure:
<code>fulfill</code> and <code>reject</code>. PMK 5 and 6 give you an object that has both <code>fulfill</code> and
<code>reject</code> methods, but also many variants of the method <code>resolve</code>. You can
typically just pass completion handler parameters to <code>resolve</code> and let Swift figure
out which variant to apply to your particular case (as shown in the example above).</p>

<p><em>Note</em> <code>Guarantees</code> (below) have a slightly different initializer (since they
cannot error) so the parameter to the initializer closure is just a closure. Not
a <code><a href="Classes/Resolver.html">Resolver</a></code> object. Thus do <code>seal(value)</code> rather than <code>seal.fulfill(value)</code>. This
is because there is no variations in what guarantees can be sealed with, they can
<em>only</em> fulfill.</p>
</blockquote>
<h1 id='code-guarantee-lt-t-gt-code' class='heading'><code><a href="Classes/Guarantee.html">Guarantee&lt;T&gt;</a></code></h1>

<p>Since PromiseKit 5, we have provided <code><a href="Classes/Guarantee.html">Guarantee</a></code> as a supplementary class to
<code><a href="Classes/Promise.html">Promise</a></code>. We do this to complement Swift’s strong error handling system.</p>

<p>Guarantees <em>never</em> fail, so they cannot be rejected. A good example is <code>after</code>:</p>
<pre class="highlight plaintext"><code>firstly {
    after(seconds: 0.1)
}.done {
    // there is no way to add a `catch` because after cannot fail.
}
</code></pre>

<p>Swift warns you if you don’t terminate a regular <code><a href="Classes/Promise.html">Promise</a></code> chain (i.e., not
a <code><a href="Classes/Guarantee.html">Guarantee</a></code> chain). You&rsquo;re expected to silence this warning by supplying 
either a <code>catch</code> or a <code>return</code>. (In the latter case, you will then have to <code>catch</code> 
at the point where you receive that promise.)</p>

<p>Use <code><a href="Classes/Guarantee.html">Guarantee</a></code>s wherever possible so that your code has error handling where
it&rsquo;s required and no error handling where it&rsquo;s not required.</p>

<p>In general, you should be able to use <code><a href="Classes/Guarantee.html">Guarantee</a></code>s and <code><a href="Classes/Promise.html">Promise</a></code>s interchangeably,
We have gone to great lengths to try and ensure this, so please open a ticket
if you find an issue.</p>

<hr>

<p>If you are creating your own guarantees the syntax is simpler than that of promises;</p>
<pre class="highlight swift"><code><span class="kd">func</span> <span class="nf">fetch</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">Promise</span><span class="o">&lt;</span><span class="kt">String</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kt">Guarantee</span> <span class="p">{</span> <span class="n">seal</span> <span class="k">in</span>
        <span class="n">fetch</span> <span class="p">{</span> <span class="n">result</span> <span class="k">in</span>
            <span class="nf">seal</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>

<p>Which could be reduced to:</p>
<pre class="highlight swift"><code><span class="kd">func</span> <span class="nf">fetch</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">Promise</span><span class="o">&lt;</span><span class="kt">String</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kt">Guarantee</span><span class="p">(</span><span class="nv">resolver</span><span class="p">:</span> <span class="n">fetch</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<h1 id='code-map-code-code-compactmap-code-etc' class='heading'><code>map</code>, <code>compactMap</code>, etc.</h1>

<p><code>then</code> provides you with the result of the previous promise and requires you to return
another promise.</p>

<p><code>map</code> provides you with the result of the previous promise and requires you to return
an object or value type.</p>

<p><code>compactMap</code> provides you with the result of the previous promise and requires you
to return an <code>Optional</code>. If you return <code>nil</code>, the chain fails with
<code>PMKError.compactMap</code>.</p>

<blockquote>
<p><em>Rationale</em>: Before PromiseKit 4, <code>then</code> handled all these cases, and it was
painful. We hoped the pain would disappear with new Swift versions. However,
it has become clear that the various pain points are here to stay. In fact, we
as library authors are expected to disambiguate at the naming level of our API.
Therefore, we have split the three main kinds of <code>then</code> into <code>then</code>, <code>map</code> and
<code>done</code>. After using these new functions, we realized this is much nicer in practice,
so we added <code>compactMap</code> as well (modeled on <code>Optional.compactMap</code>).</p>
</blockquote>

<p><code>compactMap</code> facilitates quick composition of promise chains. For example:</p>
<pre class="highlight swift"><code><span class="n">firstly</span> <span class="p">{</span>
    <span class="kt">URLSession</span><span class="o">.</span><span class="n">shared</span><span class="o">.</span><span class="nf">dataTask</span><span class="p">(</span><span class="o">.</span><span class="n">promise</span><span class="p">,</span> <span class="nv">with</span><span class="p">:</span> <span class="n">rq</span><span class="p">)</span>
<span class="p">}</span><span class="o">.</span><span class="n">compactMap</span> <span class="p">{</span>
    <span class="k">try</span> <span class="kt">JSONSerialization</span><span class="o">.</span><span class="nf">jsonObject</span><span class="p">(</span><span class="nv">$0</span><span class="o">.</span><span class="n">data</span><span class="p">)</span> <span class="k">as?</span> <span class="p">[</span><span class="kt">String</span><span class="p">]</span>
<span class="p">}</span><span class="o">.</span><span class="n">done</span> <span class="p">{</span> <span class="n">arrayOfStrings</span> <span class="k">in</span>
    <span class="c1">//…</span>
<span class="p">}</span><span class="o">.</span><span class="k">catch</span> <span class="p">{</span> <span class="n">error</span> <span class="k">in</span>
    <span class="c1">// Foundation.JSONError if JSON was badly formed</span>
    <span class="c1">// PMKError.compactMap if JSON was of different type</span>
<span class="p">}</span>
</code></pre>

<blockquote>
<p><em>Tip</em>: We also provide most of the functional methods you would expect for sequences,
e.g., <code>map</code>, <code>thenMap</code>, <code>compactMapValues</code>, <code>firstValue</code>, etc.</p>
</blockquote>
<h1 id='code-get-code' class='heading'><code>get</code></h1>

<p>We provide <code>get</code> as a <code>done</code> that returns the value fed to <code>get</code>.</p>
<pre class="highlight swift"><code><span class="n">firstly</span> <span class="p">{</span>
    <span class="nf">foo</span><span class="p">()</span>
<span class="p">}</span><span class="o">.</span><span class="k">get</span> <span class="p">{</span> <span class="n">foo</span> <span class="k">in</span>
    <span class="c1">//…</span>
<span class="p">}</span><span class="o">.</span><span class="n">done</span> <span class="p">{</span> <span class="n">foo</span> <span class="k">in</span>
    <span class="c1">// same foo!</span>
<span class="p">}</span>
</code></pre>
<h1 id='code-tap-code' class='heading'><code>tap</code></h1>

<p>We provide <code>tap</code> for debugging. It&rsquo;s the same as <code>get</code> but provides the
<code><a href="Enums/Result.html">Result&lt;T&gt;</a></code> of the <code><a href="Classes/Promise.html">Promise</a></code> so you can inspect the value of the chain at this
point without causing any side effects:</p>
<pre class="highlight swift"><code><span class="n">firstly</span> <span class="p">{</span>
    <span class="nf">foo</span><span class="p">()</span>
<span class="p">}</span><span class="o">.</span><span class="n">tap</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="nv">$0</span><span class="p">)</span>
<span class="p">}</span><span class="o">.</span><span class="n">done</span> <span class="p">{</span>
    <span class="c1">//…</span>
<span class="p">}</span><span class="o">.</span><span class="k">catch</span> <span class="p">{</span>
    <span class="c1">//…</span>
<span class="p">}</span>
</code></pre>
<h1 id='supplement' class='heading'>Supplement</h1>
<h2 id='code-firstly-code' class='heading'><code>firstly</code></h2>

<p>We&rsquo;ve used <code>firstly</code> several times on this page, but what is it, really? In fact,
it is just <a href="https://en.wikipedia.org/wiki/Syntactic_sugar">syntactic sugar</a>.
You don’t really need it, but it helps to make your chains more readable. Instead of:</p>
<pre class="highlight swift"><code><span class="n">firstly</span> <span class="p">{</span>
    <span class="nf">login</span><span class="p">()</span>
<span class="p">}</span><span class="o">.</span><span class="n">then</span> <span class="p">{</span> <span class="n">creds</span> <span class="k">in</span>
    <span class="c1">//…</span>
<span class="p">}</span>
</code></pre>

<p>You could just do:</p>
<pre class="highlight swift"><code><span class="nf">login</span><span class="p">()</span><span class="o">.</span><span class="n">then</span> <span class="p">{</span> <span class="n">creds</span> <span class="k">in</span>
    <span class="c1">//…</span>
<span class="p">}</span>
</code></pre>

<p>Here is a key understanding: <code>login()</code> returns a <code><a href="Classes/Promise.html">Promise</a></code>, and all <code><a href="Classes/Promise.html">Promise</a></code>s have a <code>then</code> function. <code>firstly</code> returns a <code><a href="Classes/Promise.html">Promise</a></code>, and <code>then</code> returns a <code><a href="Classes/Promise.html">Promise</a></code>, too! But don’t worry too much about these details. Learn the <em>patterns</em> to start with. Then, when you are ready to advance, learn the underlying architecture.</p>
<h2 id='code-when-code-variants' class='heading'><code>when</code> Variants</h2>

<p><code>when</code> is one of PromiseKit’s more useful functions, and so we offer several variants.</p>

<ul>
<li><p>The default <code>when</code>, and the one you should typically use, is <code><a href="Functions.html#/s:10PromiseKit4when9fulfilledAA0A0CySay1TQzGGSayxG_tAA8ThenableRzlF">when(fulfilled:)</a></code>. This variant
waits on all its component promises, but if any fail, <code>when</code> fails too, and thus the chain <em>rejects</em>. 
It&rsquo;s important to note that all promises in the <code>when</code> <em>continue</em>. Promises have <em>no</em> control over
the tasks they represent. Promises are just wrappers around tasks.</p></li>
<li><p><code><a href="Functions.html#/s:10PromiseKit4when8resolvedAA9GuaranteeCySayAA6ResultOyxGGGAA0A0CyxGd_tlF">when(resolved:)</a></code> waits even if one or more of its component promises fails. The value produced
by this variant of <code>when</code> is an array of <code><a href="Enums/Result.html">Result&lt;T&gt;</a></code>. Consequently, this variant requires all its 
component promises to have the same generic type. See our advanced patterns guide for work-arounds
for this limitation.</p></li>
<li><p>The <code>race</code> variant lets you <em>race</em> several promises. Whichever finishes first is the result. See the
advanced patterns guide for typical usage.</p></li>
</ul>
<h2 id='swift-closure-inference' class='heading'>Swift Closure Inference</h2>

<p>Swift automatically infers returns and return types for one-line closures.
The following two forms are the same:</p>
<pre class="highlight swift"><code><span class="n">foo</span><span class="o">.</span><span class="n">then</span> <span class="p">{</span>
    <span class="nf">bar</span><span class="p">(</span><span class="nv">$0</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// is the same as:</span>

<span class="n">foo</span><span class="o">.</span><span class="n">then</span> <span class="p">{</span> <span class="n">baz</span> <span class="o">-&gt;</span> <span class="kt">Promise</span><span class="o">&lt;</span><span class="kt">String</span><span class="o">&gt;</span> <span class="k">in</span>
    <span class="k">return</span> <span class="nf">bar</span><span class="p">(</span><span class="n">baz</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>

<p>Our documentation often omits the <code>return</code> for clarity.</p>

<p>However, this shorthand is both a blessing and a curse. You may find that the Swift compiler
often fails to infer return types properly. See our <a href="Troubleshooting.md">Troubleshooting Guide</a> if
you require further assistance.</p>

<blockquote>
<p>By adding <code>done</code> to PromiseKit 5, we have managed to avoid many of these common
pain points in using PromiseKit and Swift.</p>
</blockquote>
<h1 id='further-reading' class='heading'>Further Reading</h1>

<p>The above information is the 90% you will use. We <strong>strongly</strong> suggest reading the
<a href="https://promisekit.org/reference/">API Reference</a>.
There are numerous little
functions that may be useful to you, and the documentation for everything outlined above
is more thorough at the source.</p>

<p>In Xcode, don’t forget to option-click on PromiseKit functions to access this
documentation while you&rsquo;re coding.</p>

<p>Here are some recent articles that document PromiseKit 5+:</p>

<ul>
<li><a href="https://agostini.tech/2018/10/08/using-promisekit">Using Promises - Agostini.tech</a></li>
</ul>

<p>Careful with general online references, many of them refer to PMK &lt; 5 which has a subtly
different API (sorry about that, but Swift has changed a lot over the years and thus
we had to too).</p>

          </div>
        </section>


      </article>
    </div>
    <section class="footer">
      <p>&copy; 2019 <a class="link" href="" target="_blank" rel="external"></a>. All rights reserved. (Last updated: 2019-01-15)</p>
      <p>Generated by <a class="link" href="https://github.com/realm/jazzy" target="_blank" rel="external">jazzy ♪♫ v0.9.4</a>, a <a class="link" href="https://realm.io" target="_blank" rel="external">Realm</a> project.</p>
    </section>
  </body>
</div>
</html>
